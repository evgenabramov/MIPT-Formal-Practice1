# Практикум по регулярным выражениям

[![Build Status](https://travis-ci.com/evgenabramov/MIPT-Formal-Practice1.svg?token=BTLs4oCWwqfaRL1pjb6t&branch=dev)](https://travis-ci.com/evgenabramov/MIPT-Formal-Practice1)
[![codecov](https://codecov.io/gh/evgenabramov/MIPT-Formal-Practice1/branch/dev/graph/badge.svg?token=i777yrlJt9)](https://codecov.io/gh/evgenabramov/MIPT-Formal-Practice1)

## Описаниe задачи

Обозначение: `α` - регулярное выражение в обратной польской записи, задающее язык `L`. `α` задано в алфавите `{a, b, c, 1, ., +, *}`.

Даны `α`, буква `x` и натуральное число `k`. Вывести, есть ли в языке `L` слова, содержащие префикс `x^k` (`k` символов `x` подряд).

В случае, если входная строка не является корректным регулярным выражением в обратной польской записи, необходимо выдать сообщение `ERROR` об ошибке.

## Решение

Обозначим символ, по которому ведется поиск, через `x`.
Сопоставим каждому регулярному выражению структуру `State`, которая хранит следующую информацию про язык `L`, задаваемый регулярным выражением `α`:

1. Есть ли в `L` слово, содержащее только символы `x`

2. Наибольшая длина слова из `L`, содержащего только символы `x`

3. Длина наибольшего префикса, содержащего только символы `x`, среди слов из `L`

Отметим, что эти величины независимы, то есть для одного и того же регулярного выражения их значения могут соответствовать разным словам из `L`.

Решим задачу с помощью динамического программирования.

Будем посимвольно читать регулярное выражение. Поскольку парсится выражение в обратной польской нотации, то для восстановления операндов, к которым применяется очередная операция, удобно пользоваться стеком с хранением текущих состояний. Тогда последняя операция применяется к последним двум значениям на стеке.

При этом, при чтении *буквы* в стек всегда добавляется новое состояние, которое однозначно определяется исходя из того, равен ли он `x` или нет. При чтении *операции* два верхних состояния на стеке заменяются на одно общее.

Нетрудно показать (разбор случаев), что на основании значений для двух операндов из стека, хранимых в структуре `State`, можно однозначно восстановить соответствующие значения для состояния-результата, полученного после применения очередной операции.

Таким образом, после последовательного чтения регулярного выражения будет получено **конечное состояние**, которое соответствует языку `L`.

Для получения ответа достаточно сравнить значение для конечного состояния длины наибольшего префикса, содержащего только символы `x`, с числом из ввода `k`.

## Описание запуска

```bash
python3 main.py --regex [REGEX] --symbol [SYMBOL] --number [NUMBER]
```

Где:

- `REGEX` - регулярное выражение, задающее язык `L`
- `SYMBOL` - символ, по которому ведется поиск
- `NUMBER` - число вхождений символа `SYMBOL` в префикс слова из `L`

**Запуск тестов** с информацией о покрытии (необходимый конфиг уже есть в корне репозитория):

```bash
pytest
```

Кроме того, есть актуальная информация о прохождении тестов, полученная из [Travis-CI](https://travis-ci.org) и подробная информация о покрытии тестами с красивым интерфейсом [Codecov](https://codecov.io/) (доступ через бейджи наверху этого файла).
